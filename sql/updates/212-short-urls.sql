BEGIN;
SELECT _v.register_patch('212-short-urls', NULL, NULL);

-- Support for base62 encoding
CREATE OR REPLACE FUNCTION base62_encode(i BIGINT)
  RETURNS TEXT AS
$$
DECLARE
  alphabet  TEXT := '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
  result    TEXT := '';
  rem       INT;
BEGIN
  IF i = 0 THEN
    RETURN substr(alphabet,1,1);
  END IF;
  WHILE i > 0 LOOP
    rem    := (i % 62)::INT;
    result := substr(alphabet, rem+1, 1) || result;
    i      := i / 62;
  END LOOP;
  RETURN result;
END;
$$ LANGUAGE plpgsql IMMUTABLE STRICT;

-- Clear out existing unused short URL work from years ago so we can start fresh
DROP INDEX short_url_encoded_identifier_unique_idx;
DROP TABLE short_url;
DROP SEQUENCE IF EXISTS short_url_id_seq;

CREATE TABLE short_url (
	short_url_id BIGINT GENERATED BY DEFAULT AS IDENTITY (START WITH 10000000 INCREMENT BY 1) PRIMARY KEY,
	short_code TEXT NOT NULL UNIQUE, -- Understood to be Base62, auto-populated on insert by trigger below
	base_url TEXT NOT NULL, -- Must be scheme, origin, and path (no query parameters), e.g. 'https://www.example.com/test'. Never include "?" or "#"
	query_parameters JSONB, -- Optional query parameters, e.g. '{"one":"two"}' for 'https://www.example.com/test?one=two'
	fragment TEXT, -- Optional fragment, e.g. 'abc' is the fragment for 'https://www.example.com/test?one=two#abc'.  Never include "#"
	created timestamptz NOT NULL DEFAULT now(),
	last_updated timestamptz NOT NULL DEFAULT now()
);

-- Function used by trigger to autogenerate and assign short code based on identifier
CREATE OR REPLACE FUNCTION short_url_insert_fn()
  RETURNS TRIGGER AS
$$
BEGIN
  -- 1a) base_url must start with http:// or https:// and contain no ? or #
  IF NEW.base_url !~* '^https?://[^?#]+$' THEN
    RAISE EXCEPTION
      'Invalid base_url "%": must start with "http://" or "https://" and not include "?" or "#"',
      NEW.base_url;
  END IF;

  -- 1b) fragment, if given, must not include ? or #
  IF NEW.fragment IS NOT NULL
     AND NEW.fragment ~ '[\?#]' THEN
    RAISE EXCEPTION
      'Invalid fragment "%": must not include "?" or "#"',
      NEW.fragment;
  END IF;

  -- 1c) now generate the Base62 short code from the SERIAL id
  NEW.short_code := base62_encode(NEW.short_url_id);

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER before_insert_short_url BEFORE INSERT ON short_url FOR EACH ROW EXECUTE FUNCTION short_url_insert_fn();
CREATE TRIGGER set_last_updated BEFORE INSERT OR UPDATE ON short_url FOR EACH ROW EXECUTE PROCEDURE set_last_updated();

-- Optional, if we want URLs in messages to be some different domain, e.g. 'https://go.example.com' for a short URL in an SMS.
-- In practice, that short URL would redirect back to the real URL.
-- General pattern is to INSERT a short_url and then append it as the path for message_base_url, e.g. 'https://go.example.com/fxSK' and send the message.
-- When the user clicks the link in the message, the load balancer handling 'https://go.example.com` would then redirect back to a URL
-- like `/short-urls/fxSK/redirect` which would then perform the final redirect to the full URL.
ALTER TABLE institution_url ADD COLUMN message_base_url TEXT;

COMMIT;