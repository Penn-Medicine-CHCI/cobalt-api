/*
 * Copyright 2023 Cobalt Innovations, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.cobaltplatform.api.integration.beiwe;

import javax.annotation.Nonnull;
import javax.annotation.concurrent.ThreadSafe;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.util.Arrays;
import java.util.Base64;

import static java.lang.String.format;
import static java.util.Objects.requireNonNull;
import static org.apache.commons.lang3.StringUtils.trimToNull;

/**
 * @author Cobalt Innovations, Inc.
 */
@ThreadSafe
public class BeiweCryptoManager {
	public void decryptBeiweTextFile(@Nonnull BufferedReader encryptedInputReader,
																	 @Nonnull BufferedWriter decryptedOutputWriter,
																	 @Nonnull PrivateKey rsaPrivateKey) {
		requireNonNull(encryptedInputReader);
		requireNonNull(decryptedOutputWriter);
		requireNonNull(rsaPrivateKey);

		// Beiwe text files follow this format -
		// Line 1: Base64URL-encoded (twice!) RSA-encrypted AES key
		// Lines 2..n: <Base64URL representation of the 16-byte AES key salt>:<Base64URL representation of AES-encrypted row data string>
		//
		// Details:
		//
		// The Beiwe client apps receive the public half of an RSA keypair from the server.
		// The server keeps the private key stored securely.
		//
		// The Beiwe client apps will generate an AES key per-file and use the public half of the RSA keypair to encrypt it
		// and includes it as the first line of the file.  It's the server's responsibility to decrypt the AES key using the private
		// half of the RSA keypair.
		//
		// Each line of the file will include, as its first component, an "IV" value (16-byte AES salt), as generated by the client.
		// It is the server's responsibility to use this salt in combination with the decrypted AES key to decrypt the line.
		// In other words, each line is individually encrypted.

		final String AES_ALGORITHM_NAME = "AES";
		boolean processingFirstLine = true;
		Cipher rsaDecryptCipher = createRsaDecryptCipher(rsaPrivateKey);
		SecretKeySpec aesDecryptSecretKeySpec = null;

		try {
			while (encryptedInputReader.ready()) {
				String line = trimToNull(encryptedInputReader.readLine());

				if (line == null)
					continue;

				// First ("header") line is a Base64URL-encoded (twice!) RSA-encrypted AES key.
				// Pull the AES key out and store it off so we can use it to decrypt the remainder of the lines.
				if (processingFirstLine) {
					byte[] decryptedHeaderLine = null;

					try {
						// Decrypt the Base64URL-decoded header line using RSA
						decryptedHeaderLine = rsaDecryptCipher.doFinal(Base64.getUrlDecoder().decode(line));
					} catch (IllegalBlockSizeException | BadPaddingException e) {
						throw new BeiweCryptoException(format("Unable to perform %s decryption on Beiwe text file header line: %s",
								rsaDecryptCipher.getAlgorithm(), line), e);
					}

					// Rip off any leading zero bytes from the decrypted header line
					decryptedHeaderLine = arrayWithLeadingZeroBytesRemoved(decryptedHeaderLine);

					// Base64URL-decode the "clean" header line (iOS and Android apps do this double-encoding so we must double-decode)
					byte[] aesKey = Base64.getUrlDecoder().decode(decryptedHeaderLine);

					// Finally, we arrive at the raw AES key.  Store it for use on subsequent lines
					aesDecryptSecretKeySpec = new SecretKeySpec(aesKey, AES_ALGORITHM_NAME);
					processingFirstLine = false;
				} else {
					// We are past the first line and processing a "body", which means we should have an AES key available to us.
					if (aesDecryptSecretKeySpec == null)
						throw new BeiweCryptoException(format("Unable to process body line of Beiwe text file because no %s key is available", AES_ALGORITHM_NAME));

					// Body line is of the form
					// <Base64URL representation of the 16-byte AES key salt>:<Base64URL representation of AES-encrypted row data string>
					//
					// ...so we need to verify there are in fact two distinct components to it
					String[] lineComponents = line.split(":");

					if (lineComponents == null || lineComponents.length != 2)
						throw new BeiweCryptoException(format("Beiwe text file body line is missing its separator: '%s'", line));

					// 1. Base64URL Decode the first component into an IV parameter spec
					String base64EncodedIv = trimToNull(lineComponents[0]);

					if (base64EncodedIv == null)
						throw new BeiweCryptoException(format("Beiwe text file body line has an invalid IV component: '%s'", line));

					byte[] iv = Base64.getUrlDecoder().decode(base64EncodedIv);
					IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);

					// 2. Base64URL Decode the second component, then use the AES key + IV salt to decrypt it
					String aesEncryptedLineContentInBase64 = lineComponents[1];
					Cipher aesDecryptCipher = createAesDecryptCipher(aesDecryptSecretKeySpec, ivParameterSpec);
					byte[] decryptedBytes;

					try {
						decryptedBytes = aesDecryptCipher.doFinal(Base64.getUrlDecoder().decode(aesEncryptedLineContentInBase64));
					} catch (IllegalBlockSizeException | BadPaddingException e) {
						throw new BeiweCryptoException(format("Unable to perform %s decryption on Beiwe text file body line: %s",
								aesDecryptCipher.getAlgorithm(), line), e);
					}

					// Finally, we have plaintext for this line.  Write it to our output sink
					String decryptedBytesAsString = new String(decryptedBytes, StandardCharsets.UTF_8);

					decryptedOutputWriter.write(decryptedBytesAsString);
					decryptedOutputWriter.newLine();
				}
			}
		} catch (IOException e) {
			throw new BeiweCryptoException(e);
		}
	}

	/**
	 * Convenience variant that works directly with files on the filesystem.
	 */
	public void decryptBeiweTextFile(@Nonnull Path encryptedInputFile,
																	 @Nonnull Path decryptedOutputFile,
																	 @Nonnull PrivateKey rsaPrivateKey) {
		requireNonNull(encryptedInputFile);
		requireNonNull(decryptedOutputFile);
		requireNonNull(rsaPrivateKey);

		if (!Files.isRegularFile(encryptedInputFile))
			throw new BeiweCryptoException(format("Unable to read Beiwe encrypted text file at %s", encryptedInputFile.toAbsolutePath()));

		if (Files.exists(decryptedOutputFile) && !Files.isRegularFile(decryptedOutputFile))
			throw new BeiweCryptoException(format("Decrypted Beiwe file destination is invalid: %s", decryptedOutputFile.toAbsolutePath()));

		try (BufferedReader encryptedInputFileReader = new BufferedReader(new FileReader(encryptedInputFile.toFile(), StandardCharsets.UTF_8));
				 BufferedWriter decryptedOutputFileWriter = new BufferedWriter(new FileWriter(decryptedOutputFile.toFile(), StandardCharsets.UTF_8, false))) {
			decryptBeiweTextFile(encryptedInputFileReader, decryptedOutputFileWriter, rsaPrivateKey);
		} catch (IOException e) {
			throw new BeiweCryptoException(e);
		}
	}

	@Nonnull
	protected Cipher createRsaDecryptCipher(@Nonnull PrivateKey rsaPrivateKey) {
		requireNonNull(rsaPrivateKey);

		// This is the cipher used by the Beiwe iOS and Android apps
		final String RSA_CIPHER_NAME = "RSA/ECB/NoPadding";
		Cipher rsaDecryptCipher;

		try {
			rsaDecryptCipher = Cipher.getInstance(RSA_CIPHER_NAME);
		} catch (NoSuchAlgorithmException | NoSuchPaddingException e) {
			throw new BeiweCryptoException(format("Unable to acquire %s for %s", Cipher.class.getSimpleName(), RSA_CIPHER_NAME), e);
		}

		try {
			rsaDecryptCipher.init(Cipher.DECRYPT_MODE, rsaPrivateKey);
		} catch (InvalidKeyException e) {
			throw new BeiweCryptoException(format("Invalid private key was specified for %s decryption", RSA_CIPHER_NAME), e);
		}

		return rsaDecryptCipher;
	}

	@Nonnull
	protected Cipher createAesDecryptCipher(@Nonnull SecretKeySpec secretKeySpec,
																					@Nonnull IvParameterSpec ivParameterSpec) {
		requireNonNull(secretKeySpec);
		requireNonNull(ivParameterSpec);

		final String AES_CIPHER_NAME = "AES/CBC/PKCS5Padding";
		Cipher aesDecryptCipher;

		try {
			aesDecryptCipher = Cipher.getInstance(AES_CIPHER_NAME);
		} catch (NoSuchAlgorithmException | NoSuchPaddingException e) {
			throw new BeiweCryptoException(format("Unable to acquire %s for %s", Cipher.class.getSimpleName(), AES_CIPHER_NAME), e);
		}

		try {
			aesDecryptCipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivParameterSpec);
		} catch (InvalidKeyException e) {
			throw new BeiweCryptoException(format("Invalid key was specified for %s decryption", AES_CIPHER_NAME), e);
		} catch (InvalidAlgorithmParameterException e) {
			throw new BeiweCryptoException(format("Invalid IV parameter spec was specified for %s decryption", AES_CIPHER_NAME), e);
		}

		return aesDecryptCipher;
	}

	@Nonnull
	protected byte[] arrayWithLeadingZeroBytesRemoved(@Nonnull byte[] data) {
		requireNonNull(data);

		int idx = 0;

		while (idx < data.length) {
			if (data[idx] != 0)
				break;

			idx++;
		}

		byte[] trimmedData;

		if (idx > 0 && idx < data.length)
			trimmedData = Arrays.copyOfRange(data, idx, data.length);
		else
			trimmedData = data;

		return trimmedData;
	}
}